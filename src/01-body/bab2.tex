%-----------------------------------------------------------------------------%
\chapter{\babDua}
\label{bab:2}
%-----------------------------------------------------------------------------%
Untuk menjawab pertanyaan penelitian yang diuraikan pada Bab I, dibutuhkan dasar pengetahuan yang sesuai. Informasi ini berguna untuk mengetahui potensi pengembangan aplikasi dari berbagai tulisan dan penelitian sebelumnya. Secara umum, bab ini memaparkan mengenai teknologi-teknologi yang terkait dengan pengembangan aplikasi, antara lain WebRTC, CRDT \textit{Conflict-Free Replicated Data Types}, OT (\textit{operational transformation}), dan sifat-sifat pada sebuah editor teks, terutama untuk editor kode. Bab ini juga akan memberikan gambaran mengenai penelitian terkait dan sistem-sistem aplikasi yang sudah pernah dikembangkan sebelumnya. Dalam penelitian ini, teknologi \textit{websocket} menjadi salah satu solusi alternatif yang dapat digunakan untuk PeerToCP berbasis \textit{client-server}.

\section{WebSocket}

WebSocket merupakan protokol komunikasi dengan kanal dua arah, atau biasa dikenal dengan \textit{full-duplex} melalui sebuah koneksi TCP \citep{fette2011websocket}. Protokol ini bersifat \textit{stateful}, yang berarti koneksi antara klien dan server akan terus bertahan hingga salah satu pihak memutuskan hubungannya \citep{pimentel2012communicating} dan berbeda dari protokol HTTP atau HTTPS yang bersifat \textit{stateless} yang digunakan pada sebagian besar halaman web. Pada protokol HTTP atau HTTPS, setiap permintaan atau \textit{request} yang dikirimkan terpisah satu sama lain dan koneksinya berhenti setelah respons diterima \citep{fielding1999hypertext}.

WebSocket memberikan potensi pengiriman data secara langsung untuk setiap data baru yang tersedia tanpa menginisiasi koneksi baru. Pada arsitektur perangkat lunak, teknologi ini dapat dimanfaatkan untuk membuat sebuah pola penerbit-pelanggan atau \textit{publisher-subscriber design pattern} \citep{ganaputra2015asynchronous}. Pada pola ini, klien dapat melakukan permintaan berlangganan ke suatu server dan menjalin hubungan \textit{WebSocket}. Sementara server akan senantiasa memberikan arus data terus menerus setelah adanya pembaharuan kepada setiap klien yang berlangganan. Selain itu, protokol RPC (\textit{Remote Procedure Call}) juga dapat diterapkan di atas \textit{WebSocket}. RPC merupakan istilah pada sistem terdistribusi yang bekerja seperti pemanggilan fungsi pada sebuah \textit{service} atau layanan aplikasi dengan parameter tertentu \citep{srinivasan1995rpc}. Pada \textit{WebSocket}, setiap pemanggilan \textit{request} RPC menggunakan kanal komunikasi yang sama dan sudah tersedia, sehingga memberikan latensi yang jauh lebih optimal tanpa biaya inisiasi awal tambahan.

\section{WebRTC}
WebRTC merupakan sebuah teknologi web pada browser dan perangkat telepon yang membolehkan koneksi langsung dengan basis arsitektur peer-to-peer dalam transmisi datanya. WebRTC bukan hanya API (\textit{Application Programming Interface}), namun juga termasuk protokol yang telah didefinisikan pada W3C (World Wide Web Consortium) dan IETF (Internet Engineering Task Force). WebRTC dipublikasikan sebagai teknologi \textit{open-source} oleh Google pada Mei 2011, dan API-nya secara \textit{native} dikembangkan dalam bahasa JavaScript. Terdapat beberapa komponen utama dalam WebRTC, antara lain ialah sebagai berikut.

\subsection{RTCPeerConnection}

RTCPeerConnection merupakan sebuah antarmuka yang merepresentasikan sebuah koneksi antara suatu komputer dan \textit{peer} lainnya dalam suatu jaringan \textit{peer-to-peer}. Dalam sebuah jaringan WebRTC dengan skema \textit{full mesh}, suatu komputer pada sebuah jaringan WebRTC dengan $N$ \textit{peers} akan memiliki $N-1$ RTCPeerConnection dengan setiap komputer lainnya dalam jaringan. Terdapat pula skema-skema lain yang mengoptimisasi bentuk jaringan \textit{peer-to-peer} ini dengan keuntungan dan kerugian tertentu.
    
\subsection{MediaStream}

MediaStream merepresentasikan sebuah \textit{stream} atau arus multimedia berupa suara atau video. Pada umumnya sebuah MediaStream dapat mengandung satu atau lebih MediaStreamTrack yang merupakan \textit{track} audio atau video. MediaStreamTrack dapat ditambahkan pada RTCPeerConnection yang nantinya dapat diterima oleh ujung lain dari koneksi tersebut. MediaStream akan menggunakan protokol UDP secara bawaan.
\subsection{RTCDataChannel}
RTCDataChannel merupakan kanal data yang digunakan untuk mentransmisikan data apa saja dalam sebuah RTCPeerConnection. Sebuah koneksi tersebut dapat memiliki hingga $65534$ RTCDataChannel. Berbeda dengan MediaStream, RTCDataChannel umumnya digunakan sebagai kanal untuk membagikan pesan teks atau biner antar klien. API WebRTC juga menyediakan dua jenis mode pengiriman, yakni sebagai berikut.

\begin{itemize}[noitemsep]
    \item Pengiriman pesan berurutan dan \textit{reliable}, yang konsep pengirimannya sama dengan data yang ditransmisikan dengan protokol TCP (Transmission Control Protocol). Potensi penggunaannya dapat digunakan untuk pengiriman pesan atau berkas.
    \item Pengiriman pesan yang tidak harus berurutan dan memperbolehkan kekurangan pesan yang ekuivalen dengan UDP (User Datagram Protocol). Potensi penggunannya bisa untuk permainan, pengendalian perangkat jarak jauh, serta banyak lagi karena memngurangi biaya komputasi \textit{overhead} untuk setiap transmisi datanya, sehingga mode ini bertransmisi dengan lebih cepat.
    \item Pengiriman pesan \textit{partial reliable} dengan protokol SCTP (\textit{Stream Control Transmission Protocol}) yang dapat didefinisikan waktu maksimal \textit{timeout} dan maksimal transmisi ulangnya, urutan dari pesan juga dapat dikonfigurasi.
\end{itemize}

\subsection{\textit{Signalling Server}}

Sebelum memulai sebuah koneksi antar \textit{peer} dan transmisi media dilakukan, suatu \textit{peer} hendaknya mengetahui informasi semua atau sebagian \textit{peer} lain yang terdapat dalam jaringan tersebut, tergantung dari skema arsitektur \textit{peer-to-peer} yang diimplementasi. \textit{Signalling server} bertindak sebagai sebuah server yang mengelola koneksi antar perangkat, namun tidak mengelola lalu lintas media transmisi data itu sendiri. server ini hanya sebagai perantara yang memberikan kondisi suatu jaringan dan menandakan \textit{peer} mana saja yang masih terhubung dalam jaringan tersebut. Beberapa tanggung jawab yang dilakukan oleh server ini ialah antara lain sebagai berikut.
 
\begin{itemize}[noitemsep]
    \item Membolehkan sebuah \textit{peer} untuk menemukan \textit{peer} lain di dalam jaringan.
    \item Mengarahkan pembuatan koneksi untuk \textit{peer} baru yang masuk ke dalam sebuah jaringan WebRTC.
    \item Mengulang, mematikan, atau melakukan \textit{reset} sebuah koneksi bila diperlukan.
\end{itemize}

Proses \textit{signalling} ini tidak didefinisikan caranya secara langsung dan memiliki banyak metode alternatif. Terdapat beberapa protokol yang bisa digunakan untuk melakukan \textit{signalling}, antara lain XMPP (Extensible Messaging and Presence Protocol), XHR (XML HTTP Request), dan masih banyak lagi. Salah satu yang umum digunakan lainnya adalah SIP (Session Initiation Protocol) over WebSocket. WebSocket merupakan salah satu protokol yang membuka sebuah sesi jaringan antara klien dan server, dan membolehkan pesan untuk dikirim dari dua arah tanpa memerlukan inisiasi koneksi untuk setiap transmisi datanya. Pesan ini dapat berupa data teks atau pun biner.

\subsection{SDP (\textit{Session Description Protocol})}

Untuk memulai sebuah jaringan, terdapat sebuah objek informasi yang disebut Session Description Protokol yang akan ditawarkan kepada \textit{peer} yang baru masuk ke dalam jaringan WebRTC dan berisi informasi-informasi tertentu mengenai \textit{peer} yang menawarkan tersebut. Misalnya berupa alamat URL, jenis media yang ditransmisikan, \textit{codec}, dan masih banyak lagi. SDP akan dikirimkan kepada signalling server. Setelah \textit{peer} yang ditawarkan menerima, maka \textit{peer} yang ditawarkan tersebut akan memberikan SDP-nya kepada \textit{peer} yang menawarkan, sehingga sebuah jaringan WebRTC akan terjalin. Kandidat yang dapat menerima SDP ini dideskripsikan melalui sebuah ICE Candidate, yaitu sekumpulan rute yang dapat dilalui oleh sebuah \textit{peer} untuk dapat meraih \textit{peer} lain secara langsung. Di dalam SDP, terdapat deskripsi ICE Candidates ini. Dalam beberapa kasus, ICE Candidates akan dikirimkan melalui \textit{signalling server} dengan metode \textit{trickle}, yakni terpisah dari SDP dan ditambahkan satu per satu saat ada ICE Candidate baru yang didapat dari STUN server.

\subsection{ICE (Interactive Connectivity Establishment)}

Karena sistem alamat di Internet kebanyakan masih menggunakan protokol IPv4 yang secara praktis tidak dapat memenuhi semua kebutuhan penetapan alamat sehingga setiap perangkat memiliki alamat IP yang berbeda, perangkat yang digunakan pada suatu jaringan umumnya berada di belakang lapisan NAT (\textit{Network Address Translation}). Mekanisme ini memetakan alamat IP Privat menjadi IP Publik atau sebaliknya saat paket data bertransmisi dalam jaringan. NAT pada umumnya diimplementasikan pada sebuah jaringan dalam lingkup kecil, misalnya pada Wi-fi rumah atau instansi tertentu.

Pada WebRTC, untuk mengetahui alamat \textit{peer} satu sama lain dibutuhkan suatu protokol yang disebut ICE (Interactive Connectivity Establishment). Server ICE akan mengembalikan ICE Candidate yang mendeskripsikan rute dan protokol yang harus diambil untuk mencapai suatu \textit{peer} tertentu. Terdapat dua jenis server untuk ICE, yaitu STUN (\textit{Session Traversal Utilities for NAT}) and TURN (\textit{Traversal Using Relays around NAT}).

\subsection{STUN (\textit{Session Traversal Utilities for NAT})}

Server STUN merupakan server yang mengembalikan alamat IP publik terhadap \textit{peer} yang menghubungi server itu sendiri, jenis NAT yang digunakan, dan \textit{port} NAT yang diasosiasikan dengan \textit{peer} tersebut. Pengembang umumnya menggunakan server STUN publik yang dapat digunakan secara bebas, salah satunya milik Google.

\subsection{TURN (\textit{Traversal Using Relays around NAT})}

Apabila koneksi langsung antar-\textit{peer} gagal dilakukan, maka TURN server berguna sebagai server perantara atau \textit{relay server} yang meneruskan koneksi. Hal ini bisa terjadi karena adanya \textit{firewall} yang diletakkan pada bagian mana saja dari jaringan yang memotong hubungan langsung lalu lintas dari WebRTC. TURN merupakan sebuah protokol untuk meneruskan lalu lintas jaringan yang tidak bisa dilakukan secara langsung tersebut. Sebuah TURN server memiliki public IP address yang dapat diakses oleh kedua \textit{peer}, sehingga TURN Server ini dapat bertindak sebagai sebuah jembatan dalam transmisi media antara dua buah \textit{peer} dalam sebuah jaringan WebRTC.

\section{Editor Kode Kolaboratif}

Editor kode merupakan sebuah peralatan atau aplikasi yang digunakan oleh seorang programmer untuk mengembangkan kodenya. Fungsi-fungsi dasar editor kode yang membedakannya dengan editor biasa misalnya sorotan \textit{syntax}, indentasi otomatis, dan penyocokan tanda kurung otomatis. Selain yang disebutkan, masih ada fungsi-fungsi lain yang tidak ada pada editor teks biasa. Dalam penelitian ini, semua operasi yang digunakan dalam editor kode dapat direduksi secara tidak langsung menjadi operasi-operasi pada editor teks biasa (\textit{plain text editor}). Pada \textit{plain text editor}, setiap karakter pada teks tidak mengandung informasi tambahan. Perhatikan ilustrasi pada Gambar \ref{fig:2:richtext} yang menunjukkan perubahan \textit{styling} yang dapat dilakukan pada \textit{rich text editor}. Operasi semacam ilustrasi tersebut diasumsikan tidak dapat dilakukan pula pada editor kode, karena setiap karakter dianggap tidak menyimpan informasi tambahan.

\begin{figure}
    \centering
    \includegraphics[scale=0.8]{assets/skripsi/richtext.jpg}
    \caption{Diagram Contoh Perubahan pada \textit{Rich Text Editor}}
    \label{fig:2:richtext}
\end{figure}

Pada editor kode atau teks yang bersifat kolaboratif, terdapat beberapa karakteristik yang harus dipenuhi, antara lain sebagai berikut.

\begin{itemize} [noitemsep]
    \item Setiap pengguna memiliki replikat dari dokumen teks.
    \item Pengguna bebas melakukan penyuntingan secara bersamaan tanpa ada larangan tertentu.
    \item Operasi lokal akan diterapkan langsung pada replikat lokalnya tanpa ada jeda.
    \item Operasi yang dilakukan oleh seorang pengguna akan dipropagasi pada setiap pengguna lain secara langsung dengan latensi minimal, sehingga sifat kolaborasi waktu nyata dapat terwujud.
    \item Terdapat beberapa algoritma yang akan mewujudkan konsistensi \textit{state} atau keadaan dokumen pada setiap replikatnya. Setiap operasi yang dilakukan oleh setiap pengguna akan menghasilkan dokumen yang konvergen dan identik.
    \item Operasi yang dilakukan bersifat komutatif, yang berarti terlepas dari urutan diterapkannya operasi pada suatu dokumen, hasilnya akan tetap sama melalui algoritma yang mewujudkan konsistensi ini.
\end{itemize}

\subsection{OT (\textit{Operational Transformation})}
\label{subsec:OT}

Salah satu tantangan dalam menciptakan suatu sistem terdistribusi adalah untuk memiliki suatu basis atau struktur data yang nilainya konsisten untuk setiap klien dalam sistem tersebut. Salah satu struktur data yang menjadi fokus penelitian adalah dokumen \textit{plain text}. Metode OT (\textit{Operational Transformation}) dikembangkan dengan motivasi bagi setiap pengguna dalam suatu sistem terdistribusi dapat memiliki dokumen yang sama untuk setiap perubahan yang terjadi \citep{Sun1998}. Dalam algoritma dasar OT, operasi yang digunakan adalah \texttt{insert(pos, c)}. Operasi tersebut memasukkan sebuah karakter $c$ pada indeks $\texttt{pos}$ dan setiap karakter yang posisi awalnya berada $\geq \texttt{pos}$ akan digeser ke indeks selanjutnya. Ada pula operasi \texttt{delete(pos)} atau menghapus sebuah karakter pada indeks \texttt{pos} \citep{OTOverview1}. Unit operasi seperti \texttt{insert} dan \texttt{delete} ini merupakan unit dasar dari OT \citep{OTOverview1}.

OT dibuat untuk menyelesaikan konflik operasi yang dapat terjadi tanpa mengetahui urutan terjadi antar setiap kliennya. OT secara garis besar bekerja melalui sebuah fungsi $T$, yang mentransformasikan dan menyesuaikan parameter suatu operasi $\op$ yang akan dilakukan pada suatu dokumen, berdasarkan operasi-operasi sebelumnya yang telah diterapkan pada dokumen tersebut. Terdapat dua sifat yang harus dipenuhi oleh suatu algoritma OT untuk bekerja, antara lain sebagai berikut \citep{crdtLecture, OTOverview1}.

\begin{itemize}
    \item CP1/TP1 (\textit{Convergent Property} 1 atau \textit{Transformation Property} 1), yaitu $\op_1 \circ T(\op_2, \op_1) \equiv \op_2 \circ T(\op_1, \op_2)$.
    \item CP2/TP2 (\textit{Convergent Property} 2 atau \textit{Transformation Property} 2), yaitu $T(\op_{3},\op_{1}\circ T(\op_{2},\op_{1}))=T(\op_{3},\op_{2}\circ T(\op_{1},\op_{2}))$.
\end{itemize}

\begin{figure}[h]
    \centering
    \caption{Diagram Ilustrasi OT}
    \label{fig:OTschema}
\end{figure}

\subsection{CRDT (\textit{Conflict-Free Replicated Data Type})}

CRDT merupakan suatu tipe data abstrak, yang berarti semantiknya didefinisikan dari kumpulan nilai dan operasi. Implementasi dari CRDT untuk setiap operasinya bisa berbeda-beda, tapi menghasilkan \textit{behavior} yang sama. CRDT didesain untuk disimpan pada setiap node atau \textit{peer} dalam sebuah jaringan. Oleh karena itu, implementasi CRDT yang efisien terhadap memori dan waktu juga menjadi pertimbangan dalam menggunakan struktur data ini. struktur data ini memiliki karakteristik:

\begin{itemize}[noitemsep]
    \item setiap replika bisa dimodifikasi tanpa berkoordinasi dengan replika lain; kemudian
    \item bila setiap replika dilakukan operasi yang sama tanpa memerhatikan urutannya, maka semuanya akan menghasilkan \textit{state} atau keadaan akhir yang sama.
\end{itemize}

Salah satu dari contoh CRDT yang sederhana ialah \textit{unordered set} atau \textit{himpunan tak berurut}. Pada tipe data tersebut, setiap \textit{peer} dapat melakukan operasi \texttt{insert(v)}, yaitu menambahkan suatu elemen \texttt{v} ke dalam \textit{set} atau himpunan. Selanjutnya, ada pula operasi \texttt{erase(v)} yang akan menghapus elemen \texttt{v} dalam himpunan bila ada. Dalam penelitian ini, tipe data CRDT digunakan untuk mengolah proses pengolahan teks, sehingga operasi-operasi yang terkait dengan CRDT yakni serupa dengan yang disampaikan dengan operasi pada bagian \ref{subsec:OT}, yakni \texttt{insert(pos, c)} serta \texttt{delete(pos)}.

\section{Penelitian Terkait}

\section{Aplikasi dan \textit{Framework} Terkait}

Terdapat beberapa aplikasi dan \textit{library} yang terkait dalam pengembangan sistem aplikasi PeerToCP yang dibahas dalam penelitian ini. Berbagai \textit{framework}, \textit{library}, dan sistem modul ini merupakan hasil penelitian oleh para pengembang sebelumnya. 

\subsection{Electron}

Electron merupakan salah satu \textit{framework} aplikasi desktop yang melibatkan HTML, CSS, dan JavaScript. Bagian belakang atau \textit{backend} dari Electron berjalan dengan lingkungan \textit{runtime} Node.js. Node.js merupakan bahasa yang menggunakan \textit{syntax} yang serupa dengan Javascript dan dapat dikompilasi melalui kopmilator yang disebut V8 engine. Bagian tampilan atau \textit{frontend} dari Electron memanfaatkan aplikasi \textit{Chromium} yang dapat mengolah bahasa \textit{markup} web, seperti HTML (\textit{HyperText Markup Language}), CSS (\textit{Cascading Style Sheets}), serta JavaScript.

Salah satu keuntungan menggunakan Electron adalah aplikasinya yang bersifat \textit{cross-platform} atau dapat berjalan di beragam sistem operasi, seperti Windows, GNU/Linux, atau MacOS. Keuntungan lainnya ialah karena bersifat aplikasi desktop, Electron dapat mengakses berbagai macam fungsi antar muka sistem operasi, seperti memanggil subproses pada kernel dan menulis berkas. Karena \textit{frontend}-nya yang menggunakan bahasa web pula, aplikasi yang dibuat dengan Electron cenderung lebih mudah untuk dipindahkan dan diadaptasi dengan fungsi terbatas pada web.


\subsection{Yjs}

Yjs merupakan sebuah \textit{framework} library yang mengimplementasi CRDT yang disebut dengan YATA (\textit{Yet Another Transformation Approach}) \citep{Nicolaescu2016yjs}. 

\subsubsection{y-docs}

\subsubsection{y-protocols}

\subsubsection{y-websocket}

\subsubsection{y-webrtc}

\subsection{Codemirror}

Codemirror merupakan komponen \textit{frontend} editor kode yang dapat diolah oleh peramban web. Codemirror menyediakan banyak ekstensi, aksesibilitas tinggi, serta dukungan untuk berbagai macam bahasa pemrograman. Codemirror berguna untuk menampilkan editor kode dan memiliki ekstensi yang menghubungkannya dengan Yjs dan sudah diuji oleh pengembang Codemirror.

\subsection{Xterm.js}

Xterm.js merupakan salah satu komponen \textit{frontend} yang menampilkan terminal melalui bahasa yang dapat diolah oleh web. Xterm.js memiliki antarmuka yang bisa menerima dan meneruskan data dari peramban (\textit{browser}) yang dapat dihubungkan dengan sebuah proses berjalan pada kernel. Xterm.js dikembangkan tanpa memerlukan dependensi, sehingga cocok digunakan untuk pengembangan sistem yang membutuhkan tampilan \textit{shell} secara instan.

\subsection{Node-pty}

Node-pty merupakan \textit{library} Node.js yang memberikan antarmuka untuk melakukan \textit{fork} proses dengan deskriptor berkas \textit{pseudoterminal}. Node-pty mengizinkan adanya aliran data untuk baca dan tulis dengan proses berjalan pada kernel. Node-pty berguna untuk menjalankan berkas hasil kompilasi yang bersifat CLI (\textit{Command Line Interface}) yang tidak memiliki tampilan grafik untuk pengguna. Node-pty juga bersifat \textit{cross-platform} mendukung sistem operasi Windows, GNU/Linux, dan MacOS.

\subsection{ShareJS}



